import pandas as pd
import numpy as np
from baseSignal_Modified import base_feature
import talib as ta
from feature_cal_supporting import *


class Transaction_LON(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		high_series = price_series.rolling(rolling_time_n, closed='left').max()
		low_series = price_series.rolling(rolling_time_n, closed='left').min()
		VOL = vol_series.rolling(rolling_time_n, closed='left').sum()
		LC = rolling_cal(price_series, rolling_time_n, lc_)
		VID = series_clean(VOL / (high_series - low_series) * 100)
		RC = (price_series - LC) * VID

		LONG = RC.rolling(rolling_time_n3, closed='left').sum()
		DIFF = LONG.rolling(rolling_time_n, closed='left').sum()
		DEA = LONG.rolling(rolling_time_n2, closed='left').sum()
		LON = DIFF - DEA
		LONMA = LON.rolling(rolling_time_n2, closed='left').mean()
		rolling_mean = LONMA.rolling(rolling_time_n3, closed='left').mean()
		rolling_std = LONMA.rolling(rolling_time_n3, closed='left').std()
		result = (LONMA - rolling_mean) / rolling_std
		return result


class Transaction_ZLJC(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		high_series = price_series.rolling(rolling_time_n, closed='left').max()
		low_series = price_series.rolling(rolling_time_n, closed='left').min()
		ref_low = rolling_cal(low_series, rolling_time_n, lc_)
		VOL = vol_series.rolling(rolling_time_n, closed='left').sum()
		VAR1 = (price_series + high_series + low_series) / 3
		VAR2 = (VAR1 * 2 - ref_low - high_series) * VOL / 10000 / (high_series - low_series)
		VAR3 = series_clean(VAR2).rolling(rolling_time_n2, closed='left').mean_()
		rolling_mean = VAR3.rolling(rolling_time_n3, closed='left').mean()
		rolling_std = VAR3.rolling(rolling_time_n3, closed='left').std()
		result = (VAR3 - rolling_mean) / rolling_std
		return result


class Transaction_Corr_Adjusted_Returns(base_feature):
	param_list = ['nperiod']
	def feature(self, data_fed, nperiod):
		stk_data = data_fed['transaction_data'].dropna()
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series

		rolling_time_n = str(nperiod * 3) + 'S'
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		VOL = vol_series.rolling(rolling_time_n, closed='left').sum()
		LC = rolling_cal(price_series, rolling_time_n, lc_)
		roll_corr = rolling_corr(VOL, price_series, rolling_time_n).abs()
		result = ((price_series / LC) - 1) * 100 * rolling_corr
		return result


class Transaction_delta_VOL_Adjusted_Returns(base_feature):
	param_list = ['nperiod']
	def feature(self, data_fed, nperiod):
		stk_data = data_fed['transaction_data'].dropna()
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series

		rolling_time_n = str(nperiod * 3) + 'S'
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		VOL = vol_series.rolling(rolling_time_n, closed='left').sum()
		vol_lc = rolling_cal(VOL, rolling_time_n, lc_)
		sign_delta_vol = np.sign(vol_series - vol_lc)
		LC = rolling_cal(price_series, rolling_time_n, lc_)
		result = ((price_series / LC) - 1) * 100 * rolling_corr * sign_delta_vol
		return result


class Transaction_alpha101_22(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = rolling_cal(price_series, rolling_time_n, close_)
		high_series = rolling_cal(price_series, rolling_time_n, high_)
		VOL = rolling_cal(vol_series, rolling_time_n, vol_sum)
		roll_corr = rolling_corr(VOL, close_series, rolling_time_n).abs()
		delta_corr = rolling_cal(roll_corr, rolling_time_n2, diff_)
		std_close = close_series.rolling(rolling_time_n2, closed='left').std()
		temp_result = std_close * delta_corr
		rolling_mean = temp_result.rolling(rolling_time_n3, closed='left').mean()
		rolling_std = temp_result.rolling(rolling_time_n3, closed='left').std()
		result = (temp_result - rolling_mean) / rolling_std
		return result


class Transaction_alpha101_25(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = price_series
		high_series = close_series.rolling(rolling_time_n, closed='left').max()
		close_t_vol = close_series * vol_series
		VOL = vol_series.rolling(rolling_time_n, closed='left').sum()
		VWAP = close_t_vol.rolling(rolling_time_n, closed='left').sum() / VOL
		ADV = vol_series.rolling(rolling_time_n2, closed='left').sum()
		LC = rolling_cal(close_series, rolling_time_n, lc_)
		result = series_clean(((close_series / LC) - 1) * 100)
		temp_result = ADV * result * VWAP * (high_series - close_series)
		rolling_mean = temp_result.rolling(rolling_time_n3, closed='left').mean()
		rolling_std = temp_result.rolling(rolling_time_n3, closed='left').std()
		result = (temp_result - rolling_mean) / rolling_std
		return result


class Transaction_alpha101_32(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):
		print('in feature')

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = price_series
		high_series = close_series.rolling(rolling_time_n, closed='left').max()
		mean_close = close_series.rolling(rolling_time_n2, closed='left').mean()
		p1 = (mean_close - close_series) / mean_close

		close_t_vol = close_series * vol_series
		VOL = vol_series.rolling(rolling_time_n, closed='left').sum()
		VWAP = close_t_vol.rolling(rolling_time_n, closed='left').sum() / VOL
		LC = rolling_cal(price_series, rolling_time_n, lc_)
		roll_corr = rolling_corr(VWAP, LC, rolling_time_n2)
		mean_roll_corr = roll_corr.rolling(rolling_time_n3, closed='left').mean()
		p2 = roll_corr / mean_roll_corr
		result = p1 + p2
		return result


class Transaction_alpha101_53(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = price_series
		high_series = price_series.rolling(rolling_time_n, closed='left').max()
		low_series = price_series.rolling(rolling_time_n, closed='left').min()
		open_series = rolling_cal(price_series, rolling_time_n, lc_)
		result = (close_series - low_series) * open_series ** 5 / ((high_series - low_series) * close_series ** 5)
		return result


class Transaction_alpha101_55(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = price_series
		high_series = price_series.rolling(rolling_time_n, closed='left').max()
		low_series = price_series.rolling(rolling_time_n, closed='left').min()
		ts_high = high_series.rolling(rolling_time_n2, closed='left').max()
		ts_low = low_series.rolling(rolling_time_n2, closed='left').min()
		p1 = (close_series - ts_low) / (ts_high - ts_low)
		result = rolling_corr(p1, vol_series, rolling_time_n2)
		return result


class Transaction_alpha101_53(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = price_series
		high_series = price_series.rolling(rolling_time_n, closed='left').max()
		low_series = price_series.rolling(rolling_time_n, closed='left').min()
		quotient = (2 * close_series - low_series - high_series) / (close_series - low_series)
		quotient_lc = rolling_cal(quotient, rolling_time_n2, lc_)
		result = quotient - quotient_lc
		return result



class Transaction_alpha101_61(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		rolling_time_n3 = str(nperiod * 20) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = price_series
		adv = vol_series.rolling(rolling_time_n2, closed='left').mean()
		close_t_vol = close_series * vol_series
		VOL = vol_series.rolling(rolling_time_n, closed='left').sum()
		VWAP = close_t_vol.rolling(rolling_time_n, closed='left').sum() / VOL
		ts_VWAP = VWAP.rolling(rolling_time_n2, closed='left').min()
		diff_VWAP = VWAP - ts_VWAP
		roll_corr = rolling_corr(VWAP, adv, rolling_time_n2)
		temp_result = diff_VWAP * roll_corr
		rolling_mean = temp_result.rolling(rolling_time_n3, closed='left').mean()
		rolling_std = temp_result.rolling(rolling_time_n3, closed='left').std()
		result = (temp_result - rolling_mean) / rolling_std
		return result


class Transaction_alpha101_84(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_n2 = str(nperiod * 6) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = price_series
		adv = vol_series.rolling(rolling_time_n2, closed='left').mean()
		close_t_vol = close_series * vol_series
		VOL = vol_series.rolling(rolling_time_n, closed='left').sum()
		VWAP = close_t_vol.rolling(rolling_time_n, closed='left').sum() / VOL
		ts_VWAP = VWAP.rolling(rolling_time_n2, closed='left').max()
		diff_VWAP = VWAP - ts_VWAP
		ts_rank_VWAP = rolling_cal(diff_VWAP, rolling_time_n, argsort_final_pos)
		diff_price = rolling_cal(close_series, rolling_time_n, diff_)
		result = rolling_corr(ts_rank_VWAP, diff_price, rolling_time_n)
		return result


class Transaction_price_skewness(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n2 = str(nperiod * 6) + 'S'
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		close_series = price_series
		result = close_series.rolling(rolling_time_n2, closed='left').skew()
		return result


class Transaction_vol_skewness(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()

		rolling_time_n2 = str(nperiod * 6) + 'S'
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		bs_multiplier = np.where(stk_data['BSFlag'].values == 66, 1, -1)
		signed_turnover = vol_series * bs_multiplier
		if len(vol_series) < 1:
			return vol_series
		result = vol_series.rolling(rolling_time_n2, closed='left').skew()
		return result


class Transaction_vol_skewness_corr(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n2 = str(nperiod * 6) + 'S'
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(vol_series) < 1:
			return vol_series
		bs_multiplier = np.where(stk_data['BSFlag'].values == 66, 1, -1)
		signed_turnover = vol_series * bs_multiplier
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		price_skewness = price_series.rolling(rolling_time_n2, closed='left').skew()
		turnover_skewness = signed_turnover.rolling(rolling_time_n2, closed='left').skew()
		result = rolling_corr(price_skewness, turnover_skewness, rolling_time_n2)
		return result


class Transaction_vol_skewness_corr(base_feature):
	param_list = ['nperiod']

	def feature(self, data_fed, nperiod):

		stk_data = data_fed['transaction_data'].dropna()
		rolling_time_n2 = str(nperiod * 6) + 'S'
		vol_series = stk_data['Volume'][stk_data['FunctionCode'] == 48]
		if len(vol_series) < 1:
			return vol_series
		bs_multiplier = np.where(stk_data['BSFlag'].values == 66, 1, -1)
		signed_turnover = vol_series * bs_multiplier
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		price_skewness = price_series.rolling(rolling_time_n2, closed='left').skew()
		turnover_skewness = signed_turnover.rolling(rolling_time_n2, closed='left').skew()
		result = rolling_corr(price_skewness, turnover_skewness, rolling_time_n2)
		return result


class Transaction_OLD_VR(base_feature):
	param_list = ['nperiod']
	def feature(self, data_fed, nperiod):
		stk_data = data_fed['transaction_data'].dropna()
		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		vols = stk_data['Turnover'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series
		if len(vols) < 1:
			return vols

		rolling_time_n = str(nperiod * 3) + 'S'
		rolling_time_m = str(nperiod * 6) + 'S'
		rolling_time = str(nperiod * 9) + 'S'

		close_series = rolling_cal(price_series, rolling_time_n, close_)
		lc_series = rolling_cal(price_series, rolling_time_n, lc_)
		vol_series = rolling_cal(vols, rolling_time_n, vol_sum)

		condition_1 = close_series > lc_series
		condition_2 = close_series < lc_series
		condition_3 = close_series == lc_series
		TH = (iF(condition_1, vol_series.values, 0, close_series.index)).rolling(rolling_time, closed='left').apply(vol_sum, raw=True)
		TL = (iF(condition_2, vol_series.values, 0, close_series.index)).rolling(rolling_time, closed='left').apply(vol_sum, raw=True)
		TQ = (iF(condition_3, vol_series.values, 0, close_series.index)).rolling(rolling_time, closed='left').apply(vol_sum, raw=True)
		VR = (TH * 2 + TQ) / (TL * 2 + TQ)
		VR = pd.Series(np.where(np.isfinite(VR.values), VR.values, np.nan), index=VR.index).ffill().fillna(0)
		if len(VR) < 1:
			return VR
		result = rolling_cal(VR, rolling_time_m, diff_mean)
		return result


class Transaction_OLD_UOS(base_feature):
	param_list = ['nperiod']
	def feature(self, data_fed, nperiod):
		stk_data = data_fed['transaction_data'].dropna()


		rolling_time = str(nperiod * 3) + 'S'
		M1 = nperiod * 3
		M2 = nperiod * 6
		M3 = nperiod * 12
		rolling_time_M1 = str(M1) + 'S'
		rolling_time_M2 = str(M2) + 'S'
		rolling_time_M3 = str(M3) + 'S'

		price_series = stk_data['Price'][stk_data['FunctionCode'] == 48]
		if len(price_series) < 1:
			return price_series

		close_series = rolling_cal(price_series, rolling_time, close_)
		high_series = rolling_cal(price_series, rolling_time, high_)
		low_series = rolling_cal(price_series, rolling_time, low_)
		lc_series = rolling_cal(price_series, rolling_time, lc_)

		TH = max_(high_series, lc_series)
		TL = min_(lc_series, low_series)
		numerator_ = close_series - TL
		denominator_ = TH - TL
		ACC1 = numerator_.rolling(rolling_time_M1,  closed='left').apply(vol_sum, raw=True) / denominator_.rolling(rolling_time_M1,  closed='left').apply(vol_sum, raw=True)
		ACC2 = numerator_.rolling(rolling_time_M2,  closed='left').apply(vol_sum, raw=True) / denominator_.rolling(rolling_time_M2,  closed='left').apply(vol_sum, raw=True)
		ACC3 = numerator_.rolling(rolling_time_M3,  closed='left').apply(vol_sum, raw=True) / denominator_.rolling(rolling_time_M3,  closed='left').apply(vol_sum, raw=True)
		UOS = ACC1 * M1 * M2 + ACC2 * M1 * M3 + ACC3 * M1 * M2 / (M1 * M2 + M1 * M3 + M1 * M2)
		UOS = pd.Series(np.where(np.isfinite(UOS.values), UOS.values, np.nan), index=UOS.index).ffill().fillna(0)
		if len(UOS) < 1:
			return UOS
		result = rolling_cal(UOS, rolling_time_M2, diff_mean)
		return result


